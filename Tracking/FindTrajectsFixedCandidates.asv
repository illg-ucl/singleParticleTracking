function spot_final = FindTrajectsFixedCandidates(image_label,start_frame,end_frame,candidate_spotsX_0,candidate_spotsY_0)
% Created by Isabel Llorente Garcia November 2011.
%
% This function is very similar to FindTrajects.m but uses a fixes set of
% candidate positions for all frames in the sequence, to look for and find
% bright spots, instead of looking for new candidates in every frame. 
% This is useful for unusual images, dim spots, in vitro data of single
% fluorophores, etc...
%
% This function takes an image_label such as '513', '490', etc... 
% which corresponds to a certain .sif number of image sequence,
% and then finds all trajectories of the bright fluorescent spots in time.
%
% Inputs start_frame and end_frame give the frame numbers to analyse.
%
% Inputs candidate_spotsX_0 and candidate_spotsY_0 are vectors with the x
% and y postitions of the candidates to bright spots. These can be found
% from function findCandidateSpots.m. For instance:
% A = frameAverage('mCherry','563',13,80,1); % eg. use a frame average to find candidate spots.
% A1=A(1:225,:); % select only the top strip of the image.
% [xA1 yA1] = findCandidateSpots(mat2gray(A1),2);
% sA1 = FindTrajectsFixedCandidates('563',13,80,xA1,yA1);
%
% Reads .sif image sequence data and then for each frame:
% uses fixed list of candidate spots (input vectors),
% joins them to spots found and accepted on previous frame,
% eliminates coincidences in those candidates (points closer than 1 pixel),
% within all candidates, it finds actual spot centres through iterative Gaussian masking,
% and accepts only found spot centres with clipping flag equal to zero, constrained width and large enough SNR,
% eliminates coincidences from previously accepted found spot centres.
% Resulting final accepted spot centres are saved in the structure array spot_final.
% Then link spots into trajectory segments: For second frame do differently
% and check only spots in 1st frame and compare to spots in second frame.
% For rest of frames (for frame k): A) first check loose spots (TrajNumber=0) two frames
% ago (k-2) and compare to spots in current frame (k).
% B) then check all spots in previous frame (k-1) and compare to spots in
% current frame (k).
% To decide on the best asignment of pairs of spots (link), we build up
% matrices of pair-wise distances, ratio of intensities and ratio of sigmas
% of all pairs of spots in the two frames being compared, and take the
% winning asignment as that with the smallest pairwise distance.
% The intensity ratio and ratio of sigmas has to be within certain min and
% max bounds too.
%
% start_frame and end_frames are the frames through which the loop runs to
% find centres of bright spots.
%
% Output:
% The output, spot_final, is a structure array with end_frame by L elements,
% each of which is a structure with fields: CentreX, CentreY, IspTot,
% Sigma, IbgAvg, IbgTot, IinnerTot, ClipFlag, FrameNumber and SpotNumber.
% Along the dimension L, we have the different bright spots found on each
% frame (L will usually be the number of spot centres found in frame_start,
% or the largest number of spots ever accepted).
% For example, spot_final(100,8) is a structure with the above fields
% corresponding to the eighth found spot on frame 100.
%
% Example of how to call this function:
% s0 = FindTrajectsFixedCandidates('470',5,500,xx,yy); uses
% image sequence 470 within the current folder
% and finds trajectories in it, for frames 5 to 500, using vectors xx and yy as fixed lists of candidate spots for all frames.
% Another example: 
% A = frameAverage('mCherry','563',13,80,1); % eg. use a frame average to find candidate spots.
% A1=A(1:225,:); % select only the top strip of the image.
% [xA1 yA1] = findCandidateSpots(mat2gray(A1),2);
% FindTrajectsFixedCandidates('mCherry','563',13,80,xA1,yA1)
%
% -------------------------------------------------------
%
% Note: for reading .sif files you need 'read_sif_data_direct.m',
% 'GetAndorSifSize', etc. which are currently in path:
% C:\Isabel\DataAnalysis\matlabCode\matlab\Backup_Extracting_Intensity\Eint_1.09_rodrigo&anjana\IO_Input\read_sif_data_direct.m
%

%% DEFINITIONS and PARAMETERS:
%
% define data (.sif image) directory:
% dir_data = 'Z:\Leake\Heiko Data\';
dir_data = 'C:\Isabel\ExperimData\HeikoData\';
% print data directory on command window to guide user:
disp(' ') % empty line
disp(['The data directory (.sif images) is: ',dir_data])

% Maximum number of candidate spots (if eg. 260000 candidate spots are
% found, we get an error in function pdist: "Distance matrix has more
% elements than the maximum allowed size in MATLAB"), hence, we limit the
% max number of candidate spots:
max_num_candidates = 500;

% PARAMETERS for deciding if we accept a spot centre found by the function
% findSpotCentre1frame or not:
sigmaFit_min = 1; % minimum acceptable sigma of gaussian fit to spot, in pixels (2).
sigmaFit_max = 5; % maximum acceptable sigma of gaussian fit to spot, in pixels (4).
SNR_min = 1.3; % minimum acceptable signal-to-noise ratio (at least 2) (SNR as defined in findSpotCentre1frame.m).
rsq_min = 0.1; % minimum acceptable r-square value (0.2) (goodness of gaussian fit to spot).

% PARAMETER to decide if deflation method is applied or not (subtract each
% found spot to allow detection of weaker spots):
deflate = 1;

% PARAMETERS for eliminating coincident spots:
d_coincid_cand = 1; % distance for eliminating coincidences in spot candidates.
d_coincid_found = 1; % distance for eliminating coincidences in found spot centres.

% PARAMETERS for building trajectories:
% For linking spots in current and previous frames:
d_01_max = 5; % max distance in pixels between spot centres in current and previous frames, for linking them into a trajectory (5).
Iratio_01_min = 0.5; % min ratio of total spot intensities (after bgnd subtraction) (0.5).
Iratio_01_max = 3; % max ratio of total spot intensities (after bgnd subtraction) (frame k-1/frame k) (large enough value (3) to account for blinking).
SigmaRatio_01_min = 0.5; % min ratio of spot widths (sigma of Gaussian fit) (0.5).
SigmaRatio_01_max = 2; % max ratio of spot width (sigma of Gaussian fit) (2).
% For linking loose spots in current frame and 2 frames ago:
d_02_max = 5; % max distance in pixels between spot centres in current frame and 2 frames ago.
Iratio_02_min = 0.5; % min ratio of total spot intensities (after bgnd subtraction).
Iratio_02_max = 3; % max ratio of total spot intensities (after bgnd subtraction).
SigmaRatio_02_min = 0.5; % min ratio of spot widths (sigma of Gaussian fit).
SigmaRatio_02_max = 2; % max ratio of spot width (sigma of Gaussian fit).

% Use a very large number (larger than image size in pixels) for rejected asignments:
rej = 10000;

% Alternative way of selecting image sequence file:
% uigetfile opens a file dialog box to choose data file:
% [file_data,path_data] = uigetfile({'*.sif'}, 'Chose image data sequence:');
% strcat('data (.sif image):','  ',path_data,file_data)
% open a file dialog box to choose analysis file:
% [file_analysis,path_analysis] = uigetfile({'*.xls'}, 'Chose analysis file (trajectory):');
% strcat('analysis file (.xls trajectory):','  ',path_analysis,file_analysis)

disp(' ') % empty line
disp(['The start frame for finding bright spot trajectories will be ',num2str(start_frame)]) % start_frame is an input.
disp(['The end frame for finding bright spot trajectories will be ',num2str(end_frame)]) % end_frame is an input.
% -----------------------------------------------------


%% Read in the .sif image data:
%
% Change to the Data directory:
cd(dir_data);

data_folder = strcat(cd,'\',data_set_label);
cd(data_folder); % change to the data folder
TIRF_data_folder = dir('*TIRF');  % returns a structure with all directories with the word TIRF on their name. The structure has fields 'name', 'date', 'bytes', etc.
cd(TIRF_data_folder.name); % The directory name is stored in the 'name' field of the structure.

pre3 = strcat('*_',image_label,'.sif'); % pre3 is a string to look for in order to find files in the directory containing that string
data_folder_struct = dir(pre3); % data_folder_struct is also a structure with field 'name'.
data_folder_path = strcat(cd,'\',data_folder_struct.name);
disp(' ') % empty line
disp(data_folder_path) % write .sif image path to command window.

% first get size of .sif image file: (see IO_Input folder, SifFunctions.txt, or page 95 my notebook 1):
[ReturnCode, numFrames, ImageSize, TotalAcquisitionSize]=GetAndorSifSize(data_folder_path,0);
disp(' ') % empty line
disp(['The total number of frames in this image sequence is: ',num2str(numFrames)]) %output total number of frames to command window.
% numFrames is the length of the sequence, the number of frames.
% ImageSize is the size of the image, e.g. 512*512 = 262144.
% TotalAcquisitionSize is numFrames*ImageSize

% read .sif image data. sifData is an array of 1x1 structures, as many
% columns as frames on image sequence. Read frames 1 to numFrames:
[sifData] = read_sif_data_direct(data_folder_path,numFrames,ImageSize,1,numFrames); % sifData is a cell array.
% --------------------------------------------------------------


%% Find spot centres for start_frame (first frame):

frame = sifData{start_frame}.sliceData; % extract frame data which is saved in the field 'sliceData' of each element in the cell array sifData.
% Note that frame here has intensity values which are larger than 1 and is of class single.
frame = imrotate(double(frame),90); % Transform into class double and rotate 90 degrees. Strange..., it needs to be rotated by 90 degrees...

disp(['frame number: ',num2str(start_frame)]) % print frame number to Command Window.

% frame dimensions:
frame_Ysize = size(frame,1);
frame_Xsize = size(frame,2);
% Xpos is a matrix of the same size as frame, containing x values for all
% pixels and similarly for Ypos (used in future sections):
[Xpos,Ypos] = meshgrid(1:frame_Xsize,1:frame_Ysize);

frame_Gray = mat2gray(frame); % grayscale image.

% Use fixed list of candidate-bright-spots for first frame:
% candidate_spotsX_0 and candidate_spotsY_0 are two column vectors of the same
% length containing the x and y coordinates of the candidate bright spots found on the image.
disp(['no. of fixed candidate spots: ',num2str(length(candidate_spotsX_0))])

% Error control:
    % Limit the max number of candidate spots (if eg. 260000 candidate spots are
    % found, we will get an error in function pdist: "Distance matrix has more
    % elements than the maximum allowed size in MATLAB").
    % Select only the first max_num_candidates then.
    if length(candidate_spotsX_0) > max_num_candidates
        candidate_spotsX_0 = candidate_spotsX_0(1:max_num_candidates);
        candidate_spotsY_0 = candidate_spotsY_0(1:max_num_candidates);
        disp(['NOTE!! no. of candidate spots has been limited to ',num2str(max_num_candidates)])
    end

% % Check graphically:
% imshow(frame_Gray,[]);
% hold on;
% plot(candidate_spotsX_0,candidate_spotsY_0,'*');
% figure;

n =1; % Initialise index n (index for accepted spot centres which have a clipping flag equal to zero):
frame_to_search = frame; % Initialise frame to search for spot centres.

% Find spot centre through iterative masking:
for m = 1:size(candidate_spotsX_0,1) % loop through all candidate spots.
    % Now find centre of bright spot using function findSpotCentre1frame:
    % use candidate spots as initial estimates and then iterate to find spot centre.
    % Image subarray ROI is a square of size 17x17 pixels (halfwidth is
    % 8 pixels), inner circular mask that moves inside the fixed 17x17
    % square has a radius of 5 pixels and the applied Gaussian
    % mask has a sigma of 2 pixels:
    spot_result = findSpotCentre1frame(frame_to_search,candidate_spotsX_0(m),candidate_spotsY_0(m),8,5,2);
    spot_result.FrameNumber = start_frame; % Add new field containing frame number (time) to result structure.
    
    
    if (spot_result.ClipFlag == 0 && spot_result.noConverge == 0 && ...
            spot_result.SigmaFit <= sigmaFit_max && ...
            spot_result.SigmaFit >= sigmaFit_min && ...
            spot_result.SNR >= SNR_min &&...
            spot_result.rsqFit >= rsq_min)
        % Only accept and save result of found spot if clipping flag =0 and if values of sigmaFit, signal to noise and rsquare of fit are acceptable.
        spot_result.SpotNumber = n; % Add new field containing spot number to result structure.
        spot_final(start_frame,n) = spot_result; % store "good" found spots.
        % This is also saved in the final result spot_final, structure array.
        % first index is for frame number, second index is for spot number.
        
        %-------------------------------
        if deflate==1 % see parameter section at the beginning.
            % "Deflation" process: subtract from raw frame image the corresponding
            % Gaussian fit of each found and accepted spot before finding next spot centre (enables acceptance of dimmer spots).
            %
            % Matrices containing the x and y positions in the image frame: Xpos and Ypos
            % Xpos is a matrix of the same size as frame, containing x values for all pixels and similarly for Ypos.
            % Calculate Xpos, Ypos at the beginning: [Xpos,Ypos] = meshgrid(1:frame_Xsize,1:frame_Ysize);
            % Parameters of Gaussian fit of previously accepted spot:
            x_fit = spot_final(start_frame,n).CentreX;
            y_fit = spot_final(start_frame,n).CentreY;
            I_fit = spot_final(start_frame,n).I0Fit;
            sigma_fit = spot_final(start_frame,n).SigmaFit;
            % deflated frame (frame with found spot subtracted):
            deflated_frame = frame_to_search - I_fit*exp(-((Xpos-x_fit).^2+(Ypos-y_fit).^2)/(2*sigma_fit^2));
            frame_to_search = deflated_frame; % update frame to search for finding next spot-centre.
            % % Graphical check of deflated frames:
            % subplot(1,2,1); imshow(frame,[]); % frame is the original frame (always the same).
            % subplot(1,2,2); imshow(deflated_frame,[]);
        end
        %-------------------------------
        
        n = n+1; % advance index n for accepted spot centres.
    end
end

% % display the number of accepted spot-centres for this frame:
disp(['no. of accepted spot centres in first frame: ',num2str(n-1)])

% convert results of found spot-centre positions to a useful form that can
% be used as input candidate-spots on the following frame:
if (n-1) == 0 % error control: if no spots were accepted.
    found_spot_CentreX = [];
    found_spot_CentreY = [];
    % I need to create the whole spot_final structure with all its fields
    % here, just in case the number of accepted spots in the first frame is
    % zero, in order not to get error: "Subscripted assignment between
    % dissimilar structures".
    % Save empty spot (we need this, otherwise if in the last frame the no. of accepted spots is 0, there will be no result spot_final(end_frame,:) and the following functions will fail).
    spot_final(start_frame,n).CentreX = [];
    spot_final(start_frame,n).CentreY = [];
    spot_final(start_frame,n).IspTot = [];
    spot_final(start_frame,n).rsqFit = [];
    spot_final(start_frame,n).SigmaFit = [];
    spot_final(start_frame,n).I0Fit = [];
    spot_final(start_frame,n).BgNoiseStd = [];
    spot_final(start_frame,n).IbgAvg = [];
    spot_final(start_frame,n).IbgTot = [];
    spot_final(start_frame,n).SNR = [];
    spot_final(start_frame,n).IinnerTot = [];
    spot_final(start_frame,n).ClipFlag = [];
    spot_final(start_frame,n).noConverge = [];
    spot_final(start_frame,n).TrajNumber = [];
    spot_final(start_frame,n).FrameNumber = [];
    spot_final(start_frame,n).SpotNumber = []; 
else
    found_spot_CentreX = [spot_final(start_frame,:).CentreX]'; % column vector with found CentreX positions of all candidate spots.
    found_spot_CentreY = [spot_final(start_frame,:).CentreY]'; % column vector with found CentreY positions of all candidate spots.
end

% Check graphically:
figure;
imshow(frame_Gray,[]);
hold on;
plot(found_spot_CentreX,found_spot_CentreY,'o','Color','g','MarkerSize',10) % plot accepted spot centres in green.
pause(0.1); % this pause is needed to give time for the plot to appear
hold off;
% -----------------------------------------------------------------------


%% Calculate frame average of selected frames:

% % Initialise frame accumulation in order to later calculate a frame average:
% frame_accumul = zeros(frame_Ysize,frame_Xsize);
%
% for k = start_frame:end_frame  % loop through frames.
%     % Get frame data:
%     frame = sifData{k}.sliceData; % extract frame data which is stored in the field 'sliceData'.
%     frame = imrotate(double(frame),90);
%     % Accummulate frames to then calculate frame average:
%     frame_accumul = frame_accumul + frame;
% end
%
% % Calculate frame average as the accumulation of all frames divided by the number of frames:
% frame_avg = frame_accumul/(end_frame-start_frame+1);
% % imshow(frame_avg,[]); % for graphical inspection


%% Obtain cell mask and cell boundaries from the frame average:

% frame_avg_Gray = mat2gray(frame_avg); % The input of function "getCellMaskAndBoundary" needs to be a grayscale image.
% [SignalMask CellBoundaryMask] = getCellMaskAndBoundary(frame_avg_Gray);

% Exclude pixels around the horizontal line that separates top and bottom
% channels from SignalMask?


%% Find candidate spots on the frame average:

% % Use grayscale frame average:
%[candidate_spotsX_00 candidate_spotsY_00] = findCandidateSpots(frame_avg_Gray,1); % Method 1 works better here.
% % we might use these candidates or not...



%% Loop through selected frames:

tr =1; % initialise trajectory index.

for k = (start_frame+1):end_frame
    % to go through all frames do instead: for k = 1:length(sifData)
    
    frame = sifData{k}.sliceData; % extract frame data which is stored in the field 'sliceData'.
    frame = imrotate(double(frame),90); % class double with original intensity values.
    
    imshow(frame,[],'Border','tight','InitialMagnification',150); % show image scaled between its min and max values ([]).
    hold on;
    
    disp(['frame number: ',num2str(k)]) % print frame number to Command Window.
    
    frame_Gray = mat2gray(frame); % grayscale image.
    
    %-------------------------------------
    % the subindex "_0" in candidate_spotsX_0 indicates the fixed list of spot
    % candidates for all frames. On the other hand,
    % found_spot_CentreX and found_spot_CentreY are the
    % accepted spot-centre positions coming from the previous frame.
    disp(['no. of fixed candidate spots: ',num2str(length(candidate_spotsX_0))])
    %-------------------------------------
    
    % Join accepted spot-centre positions from previous frame with
    % fixed list of candidate spots to use them as new candidates for this frame:
    candidate_spotsX = [found_spot_CentreX; candidate_spotsX_0];
    candidate_spotsY = [found_spot_CentreY; candidate_spotsY_0];
    
%          % Plot fixed candidate spots in yellow and found spot centres from
%          % previous frame in cyan
%           plot(candidate_spotsX_0,candidate_spotsY_0,'+','Color','y','MarkerSize',3);
%           pause(0.5);
%           plot(found_spot_CentreX,found_spot_CentreY,'+','Color','c','MarkerSize',3);
%           pause(0.5);

    disp(['no. of initial total candidate spots: ',num2str(length(candidate_spotsX))])
    
    % Error control:
    % Limit the max number of candidate spots (if eg. 260000 candidate spots are
    % found, we get an error in function pdist: "Distance matrix has more
    % elements than the maximum allowed size in MATLAB").
    % Select only the first max_num_candidates then.
    if length(candidate_spotsX) > max_num_candidates
        candidate_spotsX = candidate_spotsX(1:max_num_candidates);
        candidate_spotsY = candidate_spotsY(1:max_num_candidates);
        disp(['NOTE!! no. of initial total candidate spots has been limited to ',num2str(max_num_candidates)])
    end
    
    %----------------------------------------------
    % Eliminate coincidences in spot candidates:
    
    [candidate_spotsX candidate_spotsY pos] = eliminateCoincidentSpots(candidate_spotsX,candidate_spotsY,d_coincid_cand);
    % see C:\Isabel\myMatlabFiles\eliminateCoincidentSpots.m
    % The function checks the distances between all pairs of points with x
    % and y coordinates candidate_spotsX and candidate_spotsY respectively,
    % and removes those points (x,y) which are closer than one pixel (distance<1) to
    % another point in the list.
    
    %     % for debugging:
    %     x2 = candidate_spotsX;
    %     y2 = candidate_spotsY;
    
    disp(['no. of total candidate spots after eliminating coincidences: ',num2str(length(candidate_spotsX))])
    
    %     % Plot all candidate spots in magenta after removing coincidences:
    %      plot(candidate_spotsX,candidate_spotsY,'+','Color','m','MarkerSize',3);
    %      pause(0.5);
    %------------------------------------------------
    
    
    n =1; % Initialise index n (index for accepted spot centres which have a clipping flag equal to zero):
    frame_to_search = frame; % Initialise frame to search for spot centres.
    
    for m = 1:size(candidate_spotsX,1) % for each frame, loop throuh all the candidate spots.
        % Now find centre of bright spot using function findSpotCentre1frame:
        % use candidate spots as initial estimates and then iterate to find spot centre.
        % Image subarray ROI is a square of size 17x17 pixels (halfwidth is
        % 8 pixels), inner circular mask that moves inside the fixed 17x17
        % square has a radius of 5 pixels and the applied Gaussian
        % mask has a sigma of 2 pixels:
        spot_result = findSpotCentre1frame(frame_to_search,candidate_spotsX(m),candidate_spotsY(m),8,5,2);
        % index k is for frame number, index m is for spot number
        spot_result.FrameNumber = k; % Add new field containing frame number (time) to result structure.
        
        % accepted spot centres:
        if (spot_result.ClipFlag == 0 && spot_result.noConverge == 0 && ...
                spot_result.SigmaFit <= sigmaFit_max && ...
                spot_result.SigmaFit >= sigmaFit_min && ...
                spot_result.SNR >= SNR_min &&...
                spot_result.rsqFit >= rsq_min)
            % Only accept and save result of found spot if clipping flag =0 and if values of sigmaFit, signal to noise and rsquare of fit are acceptable.
            spot(k,n) = spot_result; % store accepted found spots in this preliminary result.
            % first index is for frame number, second index is for spot number.
            %           %--------------------------------------------------
            %           plot(spot(k,n).CentreX,spot(k,n).CentreY,'o','Color','r','MarkerSize',10); % Plot found centre spots in red
            %           %--------------------------------------------------
            if deflate==1 % see parameter section at the beginning.
                % "Deflation" process: subtract from raw frame image the corresponding
                % Gaussian fit of each found and accepted spot before finding
                % next spot centre (enables acceptance of dimmer spots).
                % Xpos and Ypos are matrices of x and y positions on image frame.
                % Parameters of Gaussian fit of previously accepted spot:
                x_fit = spot(k,n).CentreX;
                y_fit = spot(k,n).CentreY;
                I_fit = spot(k,n).I0Fit;
                sigma_fit = spot(k,n).SigmaFit;
                % deflated frame (frame with found spot subtracted):
                deflated_frame = frame_to_search - I_fit*exp(-((Xpos-x_fit).^2+(Ypos-y_fit).^2)/(2*sigma_fit^2));
                frame_to_search = deflated_frame; % update frame for finding next spot-centre.
                % % Graphical check of deflated frames:
                % subplot(1,2,1); imshow(frame,[]); % frame is the original frame (always the same).
                % subplot(1,2,2); imshow(deflated_frame,[]);
            end
            %-------------------------------
            
            n = n+1; % and advance index n for accepted spot centres.
        end
        
    end
    
    % display the number of accepted spot-centres for each frame:
    disp(['no. of accepted spot centres: ',num2str(n-1)])
    
    % % The following two lines are used together with the previous two
    % "plot" and "imshow" (commented off) lines:
    pause(0.1); % this pause is needed to give time for the plot to appear
    %    hold off;
    
    % convert results of found spot-centre positions to a useful form that can
    % be used as input candidate-spots on the following frame:
    if (n-1) == 0 % error control: if no spots were accepted.
        found_spot_CentreX = [];
        found_spot_CentreY = [];
        spot_final(k,n).SpotNumber = []; % Save empty spot (we need this, otherwise if in the last frame the no. of accepted spots is 0, there will be no result spot_final(end_frame,:) and the following functions will fail).
    else
        found_spot_CentreX = [spot(k,:).CentreX]'; % column vector with found CentreX positions of all candidate spots.
        found_spot_CentreY = [spot(k,:).CentreY]'; % column vector with found CentreY positions of all candidate spots.
        
        %-------------------------------
        % Eliminate coincidences in result of last found spots for a given frame (for distance <1):
        [found_spot_CentreX found_spot_CentreY pos_final] = eliminateCoincidentSpots(found_spot_CentreX,found_spot_CentreY,d_coincid_found);
        % see C:\Isabel\myMatlabFiles\eliminateCoincidentSpots.m
        % pos_final contains positions of selected, kept spot centres.
        %-------------------------------
        
        % Save final spots to variable final_spots:
        n=1; % index for final kept spot.
        for ii = 1:length(pos_final)
            mientras = spot(k,pos_final(ii)); % intermediate result.
            mientras.SpotNumber = n; % Add new field containing spot number to result structure.
            spot_final(k,n)=mientras; % final result structure of accepted spot centres.
            n = n+1;
        end
        % Plot found spot centres:
        pause(0.5);
        plot(found_spot_CentreX,found_spot_CentreY,'o','Color','g','MarkerSize',10) % plot final accepted spot centres in green.
        pause(0.1); % this pause is needed to give time for the plot to appear
        hold off;
        
        disp(['no. of final found spot centres after eliminating coincidences: ',num2str(length(found_spot_CentreX))])
    end
    
    
    
    %--------------------
    % LINKING SPOTS INTO TRAJECTORY SEGMENTS:
    
    % Link found and accepted spots into trajectory segments:
    
    % Trajectory index tr is initialised to 1 outside the loop through frames (k loop).
    
    % Do differently FOR SECOND FRAME (k == start_frame+1): compare only accepted spots in
    % previous and current frames:
    if k == start_frame+1 && ... % If second frame and
            (n-1)~=0 && ... % if the number of accepted spot centres is not zero and
            isempty([spot_final(k-1,:).SpotNumber])==0 && ... % at least 1 accepted spot in previous frame and
            isempty([spot_final(k,:).SpotNumber])==0 % at least 1 accepted spot in current frame.
        % There are no trajectories jet, so compare accepted spots in previous and current frames:
        N0 = max(cat(1,spot_final(k-1,:).SpotNumber));  % no. of accepted spots in previous frame.
        % Note: cat(1,spot_final(k-1,:).SpotNumber) gives a column vector with the values of SpotNumber for all non-empty accepted spots in frame k-1.
        N1 = max(cat(1,spot_final(k,:).SpotNumber));  % no. of accepted spots in current frame.
        
        % Create cell arrays with empty elements to pre-asign sizes:
        d01 = cell(N0,N1); % Note: d01 is a cell array (matrix) but d_01 below is a scalar.
        Iratio01 = cell(N0,N1); % Note: Iratio01 is a cell array (matrix) but Iratio_01 below is a scalar.
        SigmaRatio01 = cell(N0,N1); % Note: SigmaRatio01 is a cell array (matrix) but SigmaRatio_01 below is a scalar.
        
        for q0 = 1:N0 % loop though accepted spots in previous frame.
            for q1 = 1:N1 % loop though accepted spots in current frame.
                % d_01: distance between spot centres in previous and current frames:
                d_01 = sqrt((spot_final(k-1,q0).CentreX-spot_final(k,q1).CentreX)^2+(spot_final(k-1,q0).CentreY-spot_final(k,q1).CentreY)^2);
                % Iratio_01: ratio of intensities of spot centre in previous and current frames:
                Iratio_01 = spot_final(k-1,q0).IspTot/spot_final(k,q1).IspTot;
                % SigmaRatio_01: ratio of widths of spots (Gaussian fits) in previous and current frames:
                SigmaRatio_01 = spot_final(k-1,q0).SigmaFit/spot_final(k,q1).SigmaFit;
                
                %                 d_01
                %                 Iratio_01
                %                 SigmaRatio_01
                
                % Accept and save trajectory if spots in previous and
                % current frames fulfill the following conditions:
                if d_01 < d_01_max && ...  % see PARAMETERS at start of this function.
                        Iratio_01_min <= Iratio_01 && Iratio_01 <= Iratio_01_max && ...
                        SigmaRatio_01_min <= SigmaRatio_01 && SigmaRatio_01 <= SigmaRatio_01_max
                    % Asign accepted values to cell array elements to store them:
                    d01{q0,q1} = d_01; % use {} for cell arrays.
                    Iratio01{q0,q1} = Iratio_01;
                    SigmaRatio01{q0,q1} = SigmaRatio_01;
                else % rejected asignments:
                    d01{q0,q1} = rej; % Use rej for asignments not accepted (images usually 512x512arrays, so rej pix is an impossibly large distance, this is why it is chosen here).
                    Iratio01{q0,q1} = rej; % Use rej for asignments not accepted.
                    SigmaRatio01{q0,q1} = rej; % Use rej for rejected asignments.
                end
            end
            
%                         d01
%                         [d01{q0,:}]
            % Note that [d01{q0,:}] gives only non-empty elements of row q0
            % in the cell array d01 as a row vector, that's why we had to
            % give a numeric value rej to non-accepted asignments.
            
            % Note that if all asignments in previous step are rejected,
            % [d01{q0,:}] will be a list of rej values, and its minimum will
            % be rej.
            % If list of "linkable" spots, [d01{q0,:}], has no accepted
            % asignments (all values are rej):
            if min([d01{q0,:}]) == rej
                % Asign trajectory number 0 to the spot in the previous frame only:
                spot_final(k-1,q0).TrajNumber = 0;
            else % if there is at least one accepted asignment for a given spot in the previous frame:
                
                % Decide of all possible accepted spots (in current frame)
                % that could be linked to spot q0 in previous frame, which one is the best:
                % We take the best as the closest one to spot q0:
                q1_chosen = find([d01{q0,:}] == min([d01{q0,:}])); % find position of the minimum pair-wise distance.
                
%                             q1_chosen
                
                % Check if there is a better competing asignment for a given spot q1 in the current
                % frame from another spot in the previous frame.
                % Hence, check also column-wise in matrix d01 to avoid asigning a traj
                % number to a spot q1 in the current frame that had already
                % had a traj number asigned to it linking it to a different spot q0 in
                % the previous frame, which might be at a shorter distance
                % from it than the current one.
                
%                             [d01{:,q1_chosen}] % chosen column of d01 matrix of distances.
                
                % Asign trajectory numbers to structure spot_final:
                % If the found distance in that column is not the minimum one:
                if q0 ~= find([d01{:,q1_chosen}] == min([d01{:,q1_chosen}]));
                    spot_final(k-1,q0).TrajNumber = 0; % asign trajectory number 0 to spot in previous frame.
                else
                    spot_final(k-1,q0).TrajNumber = tr; % asign trajectory number to spot in previous frame, to spot_final structure.
                    spot_final(k,q1_chosen).TrajNumber = tr; % asign same trajectory number to spot in current frame.
                    tr = tr+1; % advance trajectory-number index.
                end
            end
        end
        
        
        
    else % for FRAMES k >= start_frame+2, from third chosen frame on:
        
        % A) Compare loose spots (TrajNumber is 0) two frames ago (k-2)
        % to found spots in current frame (TrajNumber is []):
        % XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        % DO maybe!!
        if (n-1)~=0 && ... % If the number of accepted spot centres is not zero and
                isempty([spot_final(k-2,:).SpotNumber])==0 && ... % at least 1 accepted spot 2 frames ago and
                isempty([spot_final(k,:).SpotNumber])==0 % at least 1 accepted spot in current frame.
            
            N0 = max(cat(1,spot_final(k-2,:).SpotNumber));  % no. of accepted spots 2 frames ago.
            N1 = max(cat(1,spot_final(k,:).SpotNumber));  % no. of accepted spots in current frame.
            
            % Create cell arrays with empty elements to pre-asign sizes.
            d02 = cell(N0,N1); % Note: d02 is a cell array (matrix) but d_02 below is a scalar.
            Iratio02 = cell(N0,N1); % Note: Iratio02 is a cell array (matrix) but Iratio_02 below is a scalar.
            SigmaRatio02 = cell(N0,N1); % Note: SigmaRatio02 is a cell array (matrix) but SigmaRatio_02 below is a scalar.
            
            for q0 = 1:N0 % loop though loose accepted spots 2 frames ago.
                if spot_final(k-2,q0).TrajNumber == 0 % only for loose (unlinked) spots (TrajNumber=0) two frames ago (so only rows q0 in matrix d01 which have unlinked spots will fill up).
                    for q1 = 1:N1 % loop though accepted spots in current frame.
                        % d_01: distance between spot centres in previous and current frames:
                        d_02 = sqrt((spot_final(k-2,q0).CentreX-spot_final(k,q1).CentreX)^2+(spot_final(k-2,q0).CentreY-spot_final(k,q1).CentreY)^2);
                        % Iratio_01: ratio of intensities of spot centre in previous and current frames:
                        Iratio_02 = spot_final(k-2,q0).IspTot/spot_final(k,q1).IspTot;
                        % SigmaRatio_01: ratio of widths of spots (Gaussian fits) in previous and current frames:
                        SigmaRatio_02 = spot_final(k-2,q0).SigmaFit/spot_final(k,q1).SigmaFit;
                        
                        %                         d_02
                        %                         Iratio_02
                        %                         SigmaRatio_02
                        
                        % Accept and save trajectory if spots in previous and
                        % current frames fulfill the following conditions:
                        if d_02 < d_02_max && ...  % see PARAMETERS at start of this function.
                                Iratio_02_min <= Iratio_02 && Iratio_02 <= Iratio_02_max && ...
                                SigmaRatio_02_min <= SigmaRatio_02 && SigmaRatio_02 <= SigmaRatio_02_max
                            % Asign accepted values to cell array elements to store them:
                            d02{q0,q1} = d_02; % use {} for cell arrays.
                            Iratio02{q0,q1} = Iratio_02;
                            SigmaRatio02{q0,q1} = SigmaRatio_02;
                        else % rejected asignments:
                            d02{q0,q1} = rej; % Use rej for asignments not accepted (images usually 512x512arrays, so rej pix is an impossibly large distance, this is why it is chosen here).
                            Iratio02{q0,q1} = rej; % Use rej for asignments not accepted.
                            SigmaRatio02{q0,q1} = rej; % Use rej for rejected asignments.
                        end
                    end
                    
%                                         d02
%                                         [d02{q0,:}]
                    % Note that [d02{q0,:}] gives only non-empty elements of the cell array d01 as a row vector.
                    
                    % Note that if all asignments in previous step are rejected,
                    % [d02{q0,:}] will be a list of rej values, and its minimum will be rej.
                    % If list of "linkable" spots, [d02{q0,:}], has no accepted asignments (all values are rej):
                    if min([d02{q0,:}]) == rej
                        % Asign trajectory number 0 to the spot two frames ago only:
                        spot_final(k-2,q0).TrajNumber = 0; % point stays loose (unlinked).
                        
                    else % if there is at least one accepted asignment for a given spot two frames ago:
                        
                        % Decide of all possible accepted/saved spots (in current frame)
                        % that could be linked to spot q0 in previous frame (of all possible asignments), which one is the best:
                        % We take the best as the closest one to spot q0:
                        q1_chosen = find([d02{q0,:}] == min([d02{q0,:}])); % find position of the minimum pair-wise distance.
                        
%                                             q1_chosen
                        
                        % Check if there is a better competing asignment for a given spot q1 in the current
                        % frame from another spot q0 two frames ago.
                        % Hence, check also column-wise in d01 to avoid asigning a traj
                        % number to a spot q1 in the current frame that had already
                        % had a traj number asigned to it linking it to a different spot q0 two frames ago which might be at a shorter distance
                        % from it than the current one.
                        
%                                             [d02{:,q1_chosen}] % chosen column of d01 matrix of distances.
                        
                        % Asign trajectory numbers to structure spot_final:
                        % If the found distance in that column is not the minimum one:
                        if q0 ~= find([d02{:,q1_chosen}] == min([d02{:,q1_chosen}]));
                            % Asign trajectory number 0 to the spot two frames ago only:
                            spot_final(k-2,q0).TrajNumber = 0; % point stays loose (unlinked).
                        else
                            spot_final(k-2,q0).TrajNumber = tr; % asign trajectory number to spot two frames ago, to spot_final structure.
                            spot_final(k,q1_chosen).TrajNumber = tr; % asign same trajectory number to spot in current frame.
                            tr = tr+1; % advance trajectory-number index.
                        end
                    end
                end
            end
        end
        
        
        % B) Compare loose spots (TrajNumber is []) and trajectories (TrajNumber is >0)
        % in previous frame (k-1) to found spots in current frame:
        if (n-1)~=0 && ... % If the number of accepted spot centres is not zero and
                isempty([spot_final(k-1,:).SpotNumber])==0 && ... % at least 1 accepted spot in previous frame.
                isempty([spot_final(k,:).SpotNumber])==0 % at least 1 accepted spot in current frame.
            
            % zzzzzzzzzzzzzzzzzzzzzzz
            N0 = max(cat(1,spot_final(k-1,:).SpotNumber));  % no. of accepted spots in previous frame.
            N1 = max(cat(1,spot_final(k,:).SpotNumber));  % no. of accepted spots in current frame.
            
            % Create cell arrays with empty elements to pre-asign sizes.
            d01 = cell(N0,N1);
            Iratio01 = cell(N0,N1);
            SigmaRatio01 = cell(N0,N1);
            
            for q0 = 1:N0 % loop though accepted spots in previous frame.
                for q1 = 1:N1 % loop though accepted spots in current frame.
                    % d_01: distance between spot centres in previous and current frames:
                    d_01 = sqrt((spot_final(k-1,q0).CentreX-spot_final(k,q1).CentreX)^2+(spot_final(k-1,q0).CentreY-spot_final(k,q1).CentreY)^2);
                    % Iratio_01: ratio of intensities of spot centre in previous and current frames:
                    Iratio_01 = spot_final(k-1,q0).IspTot/spot_final(k,q1).IspTot;
                    % SigmaRatio_01: ratio of widths of spots (Gaussian fits) in previous and current frames:
                    SigmaRatio_01 = spot_final(k-1,q0).SigmaFit/spot_final(k,q1).SigmaFit;
                    
                    %                     d_01
                    %                     Iratio_01
                    %                     SigmaRatio_01
                    
                    % Accept and save trajectory if spots in previous and
                    % current frames fulfill the following conditions:
                    if d_01 < d_01_max && ...  % see PARAMETERS at start of this function.
                            Iratio_01_min <= Iratio_01 && Iratio_01 <= Iratio_01_max && ...
                            SigmaRatio_01_min <= SigmaRatio_01 && SigmaRatio_01 <= SigmaRatio_01_max
                        % Asign accepted values to cell array elements to store them:
                        d01{q0,q1} = d_01; % use {} for cell arrays.
                        Iratio01{q0,q1} = Iratio_01;
                        SigmaRatio01{q0,q1} = SigmaRatio_01;
                    else % rejected asignments:
                        d01{q0,q1} = rej; % Use rej for asignments not accepted (images usually 512x512arrays, so rej pix is an impossibly large distance, this is why it is chosen here).
                        Iratio01{q0,q1} = rej; % Use rej for asignments not accepted.
                        SigmaRatio01{q0,q1} = rej; % Use rej for rejected asignments.
                    end
                end
                
%                                 d01
%                                 [d01{q0,:}] % last row of d01 matrix of distances.
                % Note that [d01{q0,:}] gives only non-empty elements
                % of row q0 in the cell array d01, as a row vector.
                
                % Note that if all asignments in previous step are rejected,
                % [d01{q0,:}] will be a list of rej values, and its minimum will
                % be rej.
                % If list of "linkable" spots, [d01{q0,:}], has no accepted
                % asignments (all values are rej):
                if min([d01{q0,:}]) == rej
                    
                    if isempty(spot_final(k-1,q0).TrajNumber) % if point in previous frame was not part of a trajectory (TrajNumber=[]):
                        % Asign trajectory number 0 to the spot in the previous frame only:
                        spot_final(k-1,q0).TrajNumber = 0;                       
                    end
                    
                else % if there is at least one accepted asignment for a given spot two frames ago:
                    
                    % Decide of all possible accepted/saved spots (in current frame)
                    % that could be linked to spot q0 in previous frame, which one is the best:
                    % We take the best as the closest one to spot q0:
                    q1_chosen = find([d01{q0,:}] == min([d01{q0,:}])); % find position of the minimum pair-wise distance.
                    
%                                     q1_chosen
                    
                    % Check if there is a better competing asignment for a given spot q1 in the current
                    % frame from another spot q0 in the previous frame.
                    % Hence, check also column-wise in d01 to avoid asigning a traj
                    % number to a spot q1 in the current frame that had already
                    % had a traj number asigned to it linking it to a different spot q0 in
                    % the previous frame which might be at a shorter distance
                    % from it than the current one.
                    
%                                     [d01{:,q1_chosen}]  % chosen column of d01 matrix of distances.
                    
                    % If the found distance in that column is not the minimum one:
                    if q0 ~= find([d01{:,q1_chosen}] == min([d01{:,q1_chosen}]));
                        if isempty(spot_final(k-1,q0).TrajNumber) % if point in previous frame was not part of a trajectory (TrajNumber=[]):
                            % Asign trajectory number 0 to the spot in the previous frame only:
                            spot_final(k-1,q0).TrajNumber = 0;
                        end
                    else
                        % Asign trajectory numbers to structure spot_final:
                        if spot_final(k-1,q0).TrajNumber > 0 % if point in previous frame was already part of a trajectory:
                            spot_final(k,q1_chosen).TrajNumber = spot_final(k-1,q0).TrajNumber; % asign that trajectory number to spot in current frame.
                        else % if point in previous frame was not part of a trajectory:
                            spot_final(k-1,q0).TrajNumber = tr; % asign new trajectory number to spot in previous frame.
                            spot_final(k,q1_chosen).TrajNumber = tr; % asign same trajectory number to spot in current frame.
                            tr = tr+1; % advance trajectory-number index.
                        end
                    end
                end
            end
            % zzzzzzzzzzzzzzzzzzzzzzz
        end
    end
    %-----------------
    
    
end  % loop through selected frames

% OUTPUT OF SPOT-FINDING PROCESS: spot_final:
%
% spot_final, is a structure array with end_frame x L elements,
% each of which is a structure with fields:
%     'CentreX'
%     'CentreY'
%     'IspTot'
%     'rsqFit'
%     'SigmaFit'
%     'I0Fit'
%     'BgNoiseStd'
%     'IbgAvg'
%     'IbgTot'
%     'SNR'
%     'IinnerTot'
%     'ClipFlag'
%     'TrajNumber'
%     'FrameNumber'
%     'SpotNumber'
%
% Along the dimension L, we have the different bright spots found on each
% frame (L will often be the number of spot centres found in frame_start,
% it is always the largest number of spots ever accepted on one frame).
% For example, spot_final(100,8) is a structure with the above fields
% corresponding to the eighth found spot on frame 100.
%
% Note that even if we only analyse from start_frame to end_frame,
% spot_final is a list containing empty structure arrays from index 1 to
% index start_frame, and then the found spots for the analysed frames start_frame to end_frame.
%
% The result is padded to a fixed number of spot structures for reach
% frame (the maximum no. of accepted found spots of all frames), so that for a given
% frame in which less found spots have been accepted, the remaining
% elements are padded with empty structures with empty fields [].
% To check if a given spot is empty: isempty(spot_final(101,10).CentreX)
% gives 1 if field "CentreX" of tenth spot found and accepted in frame 101
% is empty (equal to []).
%
% e.g. cat(1,spot_final(100,:).SigmaFit) gives a vector column with all the
% non-empty SigmaFit values for all spot centres accepted in frame 100.
